<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reinforcement Learning - Noise OS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0B0F14;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .title-container {
            position: absolute;
            top: 60px;
            left: 60px;
            z-index: 10;
        }

        .title {
            font-size: 28px;
            font-weight: 600;
            letter-spacing: 2px;
            color: rgba(200, 169, 110, 0.5);
            margin-bottom: 8px;
        }

        .subtitle {
            font-size: 13px;
            font-weight: 400;
            letter-spacing: 0.5px;
            color: rgba(91, 200, 180, 0.4);
        }

        .accuracy-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 5;
        }

        .accuracy-value {
            font-size: 64px;
            font-weight: 700;
            color: rgba(200, 169, 110, 1);
            font-variant-numeric: tabular-nums;
            text-shadow: 0 0 20px rgba(200, 169, 110, 0.3);
        }

        .accuracy-label {
            font-size: 14px;
            letter-spacing: 1px;
            color: rgba(91, 200, 180, 0.6);
            margin-top: 8px;
            text-transform: uppercase;
        }

        .pattern-library {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 8;
        }

        .pattern-label {
            font-size: 12px;
            letter-spacing: 1px;
            color: rgba(91, 200, 180, 0.5);
            margin-bottom: 16px;
            text-transform: uppercase;
        }

        .pattern-dots-container {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            max-width: 400px;
        }

        .floating-text {
            position: absolute;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.5px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>

    <div class="overlay">
        <div class="title-container">
            <div class="title">REINFORCEMENT LEARNING</div>
            <div class="subtitle">Every cycle makes the model more valuable</div>
        </div>

        <div class="accuracy-display">
            <div class="accuracy-value" id="accuracyValue">62%</div>
            <div class="accuracy-label">Model Accuracy</div>
        </div>

        <div class="pattern-library">
            <div class="pattern-label">Pattern Library</div>
            <div class="pattern-dots-container" id="patternContainer"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // Color palette
        const colors = {
            background: '#0B0F14',
            gold: 'rgba(200, 169, 110, 1)',
            goldDim: 'rgba(200, 169, 110, 0.3)',
            teal: 'rgba(91, 200, 180, 1)',
            tealDim: 'rgba(91, 200, 180, 0.3)',
            rose: 'rgba(200, 110, 139, 1)',
            roseDim: 'rgba(200, 110, 139, 0.3)',
            blue: 'rgba(110, 170, 200, 1)',
            blueDim: 'rgba(110, 170, 200, 0.3)',
        };

        // Canvas setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Animation state
        let animationTime = 0;
        const cycleDuration = 4000; // 4 seconds per full cycle
        const totalCycles = 8;
        const cycleWidth = canvas.width / (totalCycles + 2);

        // Particle system for background
        const particles = [];
        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.alpha = Math.random() * 0.3 + 0.1;
                this.size = Math.random() * 1.5 + 0.5;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            draw() {
                ctx.fillStyle = `rgba(91, 200, 180, ${this.alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Initialize particles
        for (let i = 0; i < 30; i++) {
            particles.push(new Particle());
        }

        // Neural network background nodes
        class NetworkNode {
            constructor(x, y, layer) {
                this.x = x;
                this.y = y;
                this.layer = layer;
                this.radius = 2 + Math.random() * 2;
                this.baseAlpha = 0.1 + Math.random() * 0.1;
            }

            draw(time) {
                const pulse = Math.sin(time * 0.002 + this.layer * 0.5) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(110, 170, 200, ${this.baseAlpha * pulse})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const networkNodes = [];
        const layers = 4;
        const nodesPerLayer = 8;
        for (let layer = 0; layer < layers; layer++) {
            for (let i = 0; i < nodesPerLayer; i++) {
                const x = (canvas.width / (layers + 1)) * (layer + 1);
                const y = (canvas.height / (nodesPerLayer + 1)) * (i + 1);
                networkNodes.push(new NetworkNode(x, y, layer));
            }
        }

        // Chart data
        class DataPoint {
            constructor(cycle, prediction, outcome, correctPrediction) {
                this.cycle = cycle;
                this.prediction = prediction;
                this.outcome = outcome;
                this.correctPrediction = correctPrediction;
                this.timestamp = Date.now();
            }
        }

        const dataPoints = [];
        function generateDataPoints() {
            dataPoints.length = 0;
            let predictionAccuracy = 0.62;

            for (let i = 0; i < totalCycles; i++) {
                const noise = (Math.random() - 0.5) * 0.1;
                const prediction = Math.min(1, Math.max(0, predictionAccuracy + noise));
                const outcome = Math.min(1, Math.max(0, predictionAccuracy + (Math.random() - 0.5) * 0.15));
                const correct = Math.abs(prediction - outcome) < 0.08;

                dataPoints.push(new DataPoint(i, prediction, outcome, correct));
                predictionAccuracy += 0.04;
            }
        }
        generateDataPoints();

        // Floating text items
        const floatingTexts = [
            'Risk confirmed âœ“',
            'Pattern learned',
            'Prediction adjusted',
            'New signal detected',
        ];

        class FloatingText {
            constructor() {
                this.text = floatingTexts[Math.floor(Math.random() * floatingTexts.length)];
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 1;
                this.vy = -1 - Math.random() * 1;
                this.alpha = 0;
                this.lifetime = 0;
                this.maxLifetime = 2000;
                this.delay = Math.random() * 1000;
                this.createdAt = Date.now();
            }

            update(time) {
                const age = time - this.createdAt;
                if (age < this.delay) return false;

                const activeTime = age - this.delay;
                this.lifetime = activeTime;

                if (this.lifetime > this.maxLifetime) {
                    return false;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Fade in and out
                if (this.lifetime < 300) {
                    this.alpha = this.lifetime / 300;
                } else if (this.lifetime > this.maxLifetime - 300) {
                    this.alpha = (this.maxLifetime - this.lifetime) / 300;
                } else {
                    this.alpha = 1;
                }

                return true;
            }

            draw() {
                ctx.font = '12px Inter, sans-serif';
                ctx.fillStyle = `rgba(91, 200, 180, ${this.alpha * 0.7})`;
                ctx.textAlign = 'center';
                ctx.fillText(this.text, this.x, this.y);
            }
        }

        const floatingTextInstances = [];
        let lastFloatingTextTime = 0;

        // Pattern dots
        const patternContainer = document.getElementById('patternContainer');
        const patternDots = [];

        function addPatternDot() {
            const dot = document.createElement('div');
            dot.style.width = '6px';
            dot.style.height = '6px';
            dot.style.borderRadius = '50%';
            dot.style.backgroundColor = colors.teal;
            dot.style.opacity = '0.3';
            dot.style.boxShadow = `0 0 8px ${colors.teal}`;
            dot.style.animation = 'pulse-pattern 1.5s ease-out forwards';
            patternContainer.appendChild(dot);
            patternDots.push(dot);

            // Limit to 24 dots
            if (patternDots.length > 24) {
                patternContainer.removeChild(patternDots[0]);
                patternDots.shift();
            }
        }

        // Add pulse animation to style
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse-pattern {
                0% {
                    opacity: 0.1;
                    transform: scale(0.5);
                }
                50% {
                    opacity: 0.6;
                    transform: scale(1);
                }
                100% {
                    opacity: 0.3;
                    transform: scale(1);
                }
            }

            @keyframes glow-match {
                0% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0; }
            }

            @keyframes glow-miss {
                0% { opacity: 0; }
                50% { opacity: 0.8; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Draw functions
        function drawChart(time) {
            const chartTop = canvas.height * 0.15;
            const chartBottom = canvas.height * 0.65;
            const chartLeft = cycleWidth;
            const chartRight = canvas.width - cycleWidth;
            const chartHeight = chartBottom - chartTop;

            // Draw chart background grid
            ctx.strokeStyle = 'rgba(91, 200, 180, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = chartTop + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(chartLeft, y);
                ctx.lineTo(chartRight, y);
                ctx.stroke();
            }

            // Calculate animation progress through cycles
            const cycleProgress = (time % cycleDuration) / cycleDuration;
            const visibleCycles = Math.floor(cycleProgress * totalCycles) + 1;

            // Draw curves
            const predictionPoints = [];
            const outcomePoints = [];

            for (let i = 0; i < visibleCycles && i < dataPoints.length; i++) {
                const dp = dataPoints[i];
                const x = chartLeft + ((i + 1) / totalCycles) * (chartRight - chartLeft);

                // Stagger the outcome curve to lag behind prediction
                const outcomeDelay = 0.3;
                const outcomeProgress = Math.max(0, cycleProgress - (i / totalCycles) - outcomeDelay);

                predictionPoints.push({
                    x: x,
                    y: chartBottom - dp.prediction * chartHeight,
                    value: dp.prediction,
                    cycle: i
                });

                if (outcomeProgress > 0) {
                    outcomePoints.push({
                        x: x,
                        y: chartBottom - dp.outcome * chartHeight,
                        value: dp.outcome,
                        cycle: i
                    });
                }
            }

            // Draw prediction curve (gold, dashed)
            if (predictionPoints.length > 0) {
                ctx.strokeStyle = colors.gold;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(predictionPoints[0].x, predictionPoints[0].y);
                for (let i = 1; i < predictionPoints.length; i++) {
                    ctx.lineTo(predictionPoints[i].x, predictionPoints[i].y);
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw prediction dots
                for (let i = 0; i < predictionPoints.length; i++) {
                    const p = predictionPoints[i];
                    ctx.fillStyle = colors.gold;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw outcome curve (teal, solid)
            if (outcomePoints.length > 0) {
                ctx.strokeStyle = colors.teal;
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(outcomePoints[0].x, outcomePoints[0].y);
                for (let i = 1; i < outcomePoints.length; i++) {
                    ctx.lineTo(outcomePoints[i].x, outcomePoints[i].y);
                }
                ctx.stroke();

                // Draw outcome dots with glow
                for (let i = 0; i < outcomePoints.length; i++) {
                    const p = outcomePoints[i];
                    const dp = dataPoints[p.cycle];

                    // Determine glow color based on match
                    if (dp.correctPrediction) {
                        // Green/teal glow
                        ctx.fillStyle = 'rgba(91, 200, 180, 0.3)';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Rose glow
                        ctx.fillStyle = 'rgba(200, 110, 139, 0.2)';
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw correction arrow
                        const nextP = predictionPoints[i];
                        if (nextP) {
                            const dx = nextP.y - p.y;
                            const len = Math.abs(dx);
                            if (len > 2) {
                                const arrowX = p.x;
                                const arrowY = p.y + dx * 0.5;
                                const arrowSize = 4;

                                ctx.strokeStyle = colors.rose;
                                ctx.lineWidth = 1.5;
                                ctx.beginPath();
                                ctx.moveTo(arrowX, p.y);
                                ctx.lineTo(arrowX, arrowY + arrowSize);
                                ctx.stroke();

                                ctx.beginPath();
                                ctx.moveTo(arrowX - arrowSize * 0.6, arrowY + arrowSize - arrowSize * 0.6);
                                ctx.lineTo(arrowX, arrowY + arrowSize);
                                ctx.lineTo(arrowX + arrowSize * 0.6, arrowY + arrowSize - arrowSize * 0.6);
                                ctx.stroke();
                            }
                        }
                    }

                    ctx.fillStyle = colors.teal;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw cycle labels
            ctx.font = '11px Inter, sans-serif';
            ctx.fillStyle = 'rgba(91, 200, 180, 0.5)';
            ctx.textAlign = 'center';
            for (let i = 0; i < totalCycles; i++) {
                const x = chartLeft + ((i + 1) / totalCycles) * (chartRight - chartLeft);
                ctx.fillText(`Cycle ${i + 1}`, x, chartBottom + 25);
            }

            // Draw legend
            ctx.font = 'bold 11px Inter, sans-serif';
            ctx.textAlign = 'left';

            // Prediction legend
            ctx.strokeStyle = colors.gold;
            ctx.setLineDash([3, 3]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(chartLeft, chartTop - 30);
            ctx.lineTo(chartLeft + 20, chartTop - 30);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = colors.gold;
            ctx.fillText('Prediction', chartLeft + 30, chartTop - 25);

            // Outcome legend
            ctx.strokeStyle = colors.teal;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(chartLeft + 150, chartTop - 30);
            ctx.lineTo(chartLeft + 170, chartTop - 30);
            ctx.stroke();
            ctx.fillStyle = colors.teal;
            ctx.fillText('Outcome', chartLeft + 180, chartTop - 25);
        }

        function updateAccuracyDisplay(time) {
            const cycleProgress = (time % cycleDuration) / cycleDuration;
            const startAccuracy = 62;
            const endAccuracy = 94;
            const currentAccuracy = Math.floor(startAccuracy + (endAccuracy - startAccuracy) * cycleProgress);

            document.getElementById('accuracyValue').textContent = currentAccuracy + '%';
        }

        function updatePatterns(time) {
            const cycleProgress = (time % cycleDuration) / cycleDuration;
            const targetDots = Math.ceil(cycleProgress * 8);

            while (patternDots.length < targetDots) {
                addPatternDot();
            }
        }

        // Main animation loop
        function animate(timestamp) {
            animationTime = timestamp;

            // Clear canvas
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw background elements
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Draw network nodes
            networkNodes.forEach(n => {
                n.draw(timestamp);

                // Draw connections between adjacent layers
                if (n.layer < layers - 1) {
                    const nextLayerNodes = networkNodes.filter(node => node.layer === n.layer + 1);
                    const randomNext = nextLayerNodes[Math.floor(Math.random() * nextLayerNodes.length)];

                    if (randomNext && Math.random() > 0.95) {
                        const pulse = Math.sin(timestamp * 0.003) * 0.5 + 0.5;
                        ctx.strokeStyle = `rgba(110, 170, 200, ${pulse * 0.1})`;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(n.x, n.y);
                        ctx.lineTo(randomNext.x, randomNext.y);
                        ctx.stroke();
                    }
                }
            });

            // Draw main chart
            drawChart(timestamp);

            // Update and draw floating text
            if (timestamp - lastFloatingTextTime > 800) {
                floatingTextInstances.push(new FloatingText());
                lastFloatingTextTime = timestamp;
            }

            floatingTextInstances.forEach((text, index) => {
                if (!text.update(timestamp)) {
                    floatingTextInstances.splice(index, 1);
                } else {
                    text.draw();
                }
            });

            // Update accuracy display
            updateAccuracyDisplay(timestamp);

            // Update pattern library
            updatePatterns(timestamp);

            requestAnimationFrame(animate);
        }

        // Start animation
        requestAnimationFrame(animate);
    </script>
</body>
</html>
