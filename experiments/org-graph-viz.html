<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>noise.os — Organizational Graph Visualization</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0B0F14; overflow: hidden; font-family: 'Inter', -apple-system, sans-serif; }
    canvas { display: block; }
    .legend {
        position: fixed; bottom: 24px; left: 24px;
        display: flex; flex-wrap: wrap; gap: 12px;
        opacity: 0; animation: fadeIn 1.5s ease 2s forwards;
    }
    .legend-item {
        display: flex; align-items: center; gap: 6px;
        font-size: 11px; color: rgba(232,236,241,0.5);
        letter-spacing: 0.05em;
    }
    .legend-dot {
        width: 8px; height: 8px; border-radius: 50%;
    }
    .title-overlay {
        position: fixed; top: 24px; left: 24px;
        opacity: 0; animation: fadeIn 1.5s ease 1s forwards;
    }
    .title-overlay h3 {
        font-size: 14px; font-weight: 600; color: rgba(200,169,110,0.7);
        letter-spacing: 0.15em; text-transform: uppercase; margin-bottom: 4px;
    }
    .title-overlay p {
        font-size: 11px; color: rgba(136,153,170,0.6);
    }
    .info-panel {
        position: fixed; top: 24px; right: 24px;
        background: rgba(26,34,48,0.85); border: 1px solid rgba(200,169,110,0.1);
        border-radius: 8px; padding: 16px 20px; min-width: 220px;
        opacity: 0; transition: opacity 0.4s ease;
        backdrop-filter: blur(12px);
    }
    .info-panel.visible { opacity: 1; }
    .info-panel h4 {
        font-size: 13px; font-weight: 600; color: #E8ECF1; margin-bottom: 4px;
    }
    .info-panel .info-type {
        font-size: 10px; letter-spacing: 0.1em; text-transform: uppercase;
        margin-bottom: 8px; padding: 2px 8px; border-radius: 100px;
        display: inline-block;
    }
    .info-panel p {
        font-size: 11px; color: rgba(136,153,170,0.8); line-height: 1.5;
    }
    .info-panel .connections {
        margin-top: 8px; font-size: 10px; color: rgba(200,169,110,0.6);
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="title-overlay">
    <h3>Organizational Graph</h3>
    <p>The structural backbone — a living model of how work flows</p>
</div>

<div class="info-panel" id="infoPanel">
    <div class="info-type" id="infoType">—</div>
    <h4 id="infoName">—</h4>
    <p id="infoDesc">Hover over a node to explore</p>
    <div class="connections" id="infoConns"></div>
</div>

<div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:#C8A96E"></div>OrgUnit</div>
    <div class="legend-item"><div class="legend-dot" style="background:#6EAAC8"></div>Capability</div>
    <div class="legend-item"><div class="legend-dot" style="background:#8BC86E"></div>Process</div>
    <div class="legend-item"><div class="legend-dot" style="background:#C86E8B"></div>Role</div>
    <div class="legend-item"><div class="legend-dot" style="background:#B08BD4"></div>System</div>
    <div class="legend-item"><div class="legend-dot" style="background:#D4A85B"></div>Product</div>
    <div class="legend-item"><div class="legend-dot" style="background:#5BC8B4"></div>Objective</div>
    <div class="legend-item"><div class="legend-dot" style="background:#E8ECF1"></div>Team</div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Colors
const COLORS = {
    OrgUnit:    { fill: '#C8A96E', glow: 'rgba(200,169,110,', label: '#C8A96E' },
    Capability: { fill: '#6EAAC8', glow: 'rgba(110,170,200,', label: '#6EAAC8' },
    Process:    { fill: '#8BC86E', glow: 'rgba(139,200,110,', label: '#8BC86E' },
    Role:       { fill: '#C86E8B', glow: 'rgba(200,110,139,', label: '#C86E8B' },
    System:     { fill: '#B08BD4', glow: 'rgba(176,139,212,', label: '#B08BD4' },
    Product:    { fill: '#D4A85B', glow: 'rgba(212,168,91,',  label: '#D4A85B' },
    Objective:  { fill: '#5BC8B4', glow: 'rgba(91,200,180,',  label: '#5BC8B4' },
    Team:       { fill: '#E8ECF1', glow: 'rgba(232,236,241,', label: '#E8ECF1' },
};

const EDGE_TYPES = {
    OWNS: { color: 'rgba(200,169,110,0.12)', dash: false },
    PERFORMS: { color: 'rgba(139,200,110,0.10)', dash: false },
    DEPENDS_ON: { color: 'rgba(200,110,139,0.08)', dash: [4, 4] },
    REPORTS_TO: { color: 'rgba(232,236,241,0.08)', dash: false },
    ENABLES: { color: 'rgba(91,200,180,0.10)', dash: [6, 3] },
    PRODUCES: { color: 'rgba(212,168,91,0.10)', dash: false },
    PARTICIPATES_IN: { color: 'rgba(176,139,212,0.08)', dash: [3, 5] },
};

// Node definitions — a realistic organizational metamodel
const nodeData = [
    // OrgUnits (the golden core)
    { id: 0,  type: 'OrgUnit',    label: 'Executive Board',       size: 16, desc: 'Top governance body' },
    { id: 1,  type: 'OrgUnit',    label: 'Product Division',      size: 13, desc: 'Product strategy & delivery' },
    { id: 2,  type: 'OrgUnit',    label: 'Engineering',           size: 13, desc: 'Technical capabilities' },
    { id: 3,  type: 'OrgUnit',    label: 'People & Culture',      size: 11, desc: 'Talent & organizational health' },
    { id: 4,  type: 'OrgUnit',    label: 'Finance',               size: 10, desc: 'Financial governance' },
    { id: 5,  type: 'OrgUnit',    label: 'Operations',            size: 11, desc: 'Operational delivery' },
    // Capabilities
    { id: 6,  type: 'Capability', label: 'Data Analytics',        size: 8,  desc: 'Organizational intelligence' },
    { id: 7,  type: 'Capability', label: 'Cloud Infrastructure',  size: 7,  desc: 'Platform foundations' },
    { id: 8,  type: 'Capability', label: 'Customer Insight',      size: 7,  desc: 'Voice of the customer' },
    { id: 9,  type: 'Capability', label: 'Agile Delivery',        size: 8,  desc: 'Adaptive execution' },
    { id: 10, type: 'Capability', label: 'Talent Development',    size: 7,  desc: 'Growth & learning' },
    // Processes
    { id: 11, type: 'Process',    label: 'Strategy Review',       size: 7,  desc: 'Quarterly strategic cadence' },
    { id: 12, type: 'Process',    label: 'Sprint Delivery',       size: 6,  desc: 'Bi-weekly delivery cycle' },
    { id: 13, type: 'Process',    label: 'Hiring Pipeline',       size: 6,  desc: 'Talent acquisition flow' },
    { id: 14, type: 'Process',    label: 'Incident Response',     size: 5,  desc: 'Operational resilience' },
    { id: 15, type: 'Process',    label: 'Budget Cycle',          size: 6,  desc: 'Financial planning cadence' },
    // Roles
    { id: 16, type: 'Role',       label: 'CPO',                   size: 6,  desc: 'Chief Product Officer' },
    { id: 17, type: 'Role',       label: 'CTO',                   size: 6,  desc: 'Chief Technology Officer' },
    { id: 18, type: 'Role',       label: 'Scrum Master',          size: 5,  desc: 'Delivery facilitation' },
    { id: 19, type: 'Role',       label: 'Data Lead',             size: 5,  desc: 'Analytics leadership' },
    { id: 20, type: 'Role',       label: 'CHRO',                  size: 6,  desc: 'Chief HR Officer' },
    // Systems
    { id: 21, type: 'System',     label: 'ERP',                   size: 7,  desc: 'Enterprise resource planning' },
    { id: 22, type: 'System',     label: 'CRM',                   size: 6,  desc: 'Customer relationship mgmt' },
    { id: 23, type: 'System',     label: 'CI/CD Pipeline',        size: 5,  desc: 'Continuous integration' },
    { id: 24, type: 'System',     label: 'HRIS',                  size: 5,  desc: 'HR information system' },
    // Products
    { id: 25, type: 'Product',    label: 'Core Platform',         size: 8,  desc: 'Primary product offering' },
    { id: 26, type: 'Product',    label: 'Mobile App',            size: 6,  desc: 'Customer-facing mobile' },
    { id: 27, type: 'Product',    label: 'API Gateway',           size: 5,  desc: 'Integration layer' },
    // Objectives
    { id: 28, type: 'Objective',  label: 'Market Expansion',      size: 7,  desc: 'Q1-Q2 strategic objective' },
    { id: 29, type: 'Objective',  label: 'Operational Excellence', size: 6, desc: 'Continuous improvement OKR' },
    { id: 30, type: 'Objective',  label: 'Talent Retention',      size: 6,  desc: 'People sustainability OKR' },
    // Teams
    { id: 31, type: 'Team',       label: 'Platform Squad',        size: 6,  desc: 'Infrastructure team' },
    { id: 32, type: 'Team',       label: 'Growth Squad',          size: 6,  desc: 'User acquisition team' },
    { id: 33, type: 'Team',       label: 'Core Experience',       size: 6,  desc: 'UX & product team' },
    { id: 34, type: 'Team',       label: 'Data Team',             size: 5,  desc: 'Analytics & insights' },
];

// Edges
const edgeData = [
    // OrgUnit hierarchy
    { from: 0, to: 1, type: 'OWNS' }, { from: 0, to: 2, type: 'OWNS' },
    { from: 0, to: 3, type: 'OWNS' }, { from: 0, to: 4, type: 'OWNS' },
    { from: 0, to: 5, type: 'OWNS' },
    // Capabilities owned by units
    { from: 2, to: 6, type: 'OWNS' }, { from: 2, to: 7, type: 'OWNS' },
    { from: 1, to: 8, type: 'OWNS' }, { from: 1, to: 9, type: 'OWNS' },
    { from: 3, to: 10, type: 'OWNS' },
    // Processes
    { from: 0, to: 11, type: 'PERFORMS' }, { from: 2, to: 12, type: 'PERFORMS' },
    { from: 3, to: 13, type: 'PERFORMS' }, { from: 5, to: 14, type: 'PERFORMS' },
    { from: 4, to: 15, type: 'PERFORMS' },
    // Roles report to units
    { from: 16, to: 1, type: 'REPORTS_TO' }, { from: 17, to: 2, type: 'REPORTS_TO' },
    { from: 18, to: 9, type: 'PARTICIPATES_IN' }, { from: 19, to: 6, type: 'REPORTS_TO' },
    { from: 20, to: 3, type: 'REPORTS_TO' },
    // Systems enable capabilities
    { from: 21, to: 4, type: 'ENABLES' }, { from: 21, to: 5, type: 'ENABLES' },
    { from: 22, to: 8, type: 'ENABLES' }, { from: 23, to: 7, type: 'ENABLES' },
    { from: 24, to: 10, type: 'ENABLES' },
    // Products
    { from: 1, to: 25, type: 'PRODUCES' }, { from: 25, to: 26, type: 'DEPENDS_ON' },
    { from: 25, to: 27, type: 'DEPENDS_ON' },
    // Objectives
    { from: 28, to: 1, type: 'ENABLES' }, { from: 28, to: 8, type: 'DEPENDS_ON' },
    { from: 29, to: 5, type: 'ENABLES' }, { from: 30, to: 3, type: 'ENABLES' },
    { from: 30, to: 10, type: 'DEPENDS_ON' },
    // Teams participate
    { from: 31, to: 2, type: 'REPORTS_TO' }, { from: 32, to: 1, type: 'REPORTS_TO' },
    { from: 33, to: 1, type: 'REPORTS_TO' }, { from: 34, to: 6, type: 'PARTICIPATES_IN' },
    // Cross-links (the interesting ones)
    { from: 6, to: 22, type: 'DEPENDS_ON' }, { from: 9, to: 12, type: 'PERFORMS' },
    { from: 31, to: 7, type: 'OWNS' }, { from: 32, to: 26, type: 'PRODUCES' },
    { from: 33, to: 25, type: 'PRODUCES' }, { from: 34, to: 19, type: 'PARTICIPATES_IN' },
    { from: 14, to: 7, type: 'DEPENDS_ON' }, { from: 11, to: 28, type: 'ENABLES' },
    { from: 12, to: 23, type: 'DEPENDS_ON' },
];

// State
let nodes = [];
let W, H;
let time = 0;
let camera = { x: 0, y: 0, zoom: 1, targetZoom: 1, targetX: 0, targetY: 0 };
let hoveredNode = null;
let mouse = { x: -9999, y: -9999 };
let zoomPhase = 0;
let zoomTimer = 0;
const ZOOM_CYCLE = 12; // seconds per zoom phase

function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}

function initNodes() {
    const cx = 0, cy = 0;
    nodes = nodeData.map((d, i) => {
        // Position by type clusters with organic spread
        let bx, by;
        const typeIndex = ['OrgUnit','Capability','Process','Role','System','Product','Objective','Team'].indexOf(d.type);
        const angle = (typeIndex / 8) * Math.PI * 2 + (Math.random() - 0.5) * 0.6;
        const radius = d.type === 'OrgUnit' ? 80 + Math.random() * 100 : 200 + Math.random() * 250;
        bx = cx + Math.cos(angle) * radius + (Math.random() - 0.5) * 120;
        by = cy + Math.sin(angle) * radius + (Math.random() - 0.5) * 120;
        // Executive Board at center
        if (i === 0) { bx = cx; by = cy; }

        return {
            ...d,
            x: bx, y: by,
            vx: 0, vy: 0,
            baseX: bx, baseY: by,
            pulsePhase: Math.random() * Math.PI * 2,
        };
    });
}

// Simple force-directed layout (runs first N frames then relaxes)
let layoutIterations = 0;
function applyForces() {
    if (layoutIterations > 300) return;
    layoutIterations++;

    const k = 0.005;
    const repulsion = 3000;
    const damping = 0.85;

    // Repulsion between all nodes
    for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
            let dx = nodes[j].x - nodes[i].x;
            let dy = nodes[j].y - nodes[i].y;
            let dist = Math.sqrt(dx * dx + dy * dy) || 1;
            let minDist = (nodes[i].size + nodes[j].size) * 3;
            if (dist < minDist) dist = minDist;
            let force = repulsion / (dist * dist);
            let fx = (dx / dist) * force;
            let fy = (dy / dist) * force;
            nodes[i].vx -= fx; nodes[i].vy -= fy;
            nodes[j].vx += fx; nodes[j].vy += fy;
        }
    }

    // Attraction along edges
    edgeData.forEach(e => {
        const a = nodes[e.from], b = nodes[e.to];
        let dx = b.x - a.x, dy = b.y - a.y;
        let dist = Math.sqrt(dx * dx + dy * dy) || 1;
        let target = 120 + (a.size + b.size) * 2;
        let force = (dist - target) * k;
        let fx = (dx / dist) * force;
        let fy = (dy / dist) * force;
        a.vx += fx; a.vy += fy;
        b.vx -= fx; b.vy -= fy;
    });

    // Center gravity
    nodes.forEach(n => {
        n.vx -= n.x * 0.0003;
        n.vy -= n.y * 0.0003;
    });

    // Apply velocity
    nodes.forEach(n => {
        n.vx *= damping; n.vy *= damping;
        n.x += n.vx; n.y += n.vy;
        n.baseX = n.x; n.baseY = n.y;
    });
}

// Camera zoom phases — focus on different areas
const zoomTargets = [
    { zoom: 1, x: 0, y: 0, label: 'Full Graph' },                              // overview
    { zoom: 1.8, nodeType: 'OrgUnit', label: 'OrgUnits' },                      // zoom into org units
    { zoom: 2.2, nodeId: 25, label: 'Product Cluster' },                        // zoom into core platform
    { zoom: 1.5, nodeType: 'Capability', label: 'Capabilities' },               // capabilities
    { zoom: 2.0, nodeId: 0, label: 'Executive Board' },                         // executive board
    { zoom: 1, x: 0, y: 0, label: 'Full Graph' },                              // back to overview
];

function updateCamera(dt) {
    zoomTimer += dt;
    if (zoomTimer > ZOOM_CYCLE) {
        zoomTimer = 0;
        zoomPhase = (zoomPhase + 1) % zoomTargets.length;
        const target = zoomTargets[zoomPhase];
        camera.targetZoom = target.zoom;
        if (target.nodeId !== undefined) {
            const n = nodes[target.nodeId];
            camera.targetX = -n.x;
            camera.targetY = -n.y;
        } else if (target.nodeType) {
            const typeNodes = nodes.filter(n => n.type === target.nodeType);
            const avgX = typeNodes.reduce((s, n) => s + n.x, 0) / typeNodes.length;
            const avgY = typeNodes.reduce((s, n) => s + n.y, 0) / typeNodes.length;
            camera.targetX = -avgX;
            camera.targetY = -avgY;
        } else {
            camera.targetX = target.x;
            camera.targetY = target.y;
        }
    }

    // Smooth interpolation
    const ease = 0.015;
    camera.zoom += (camera.targetZoom - camera.zoom) * ease;
    camera.x += (camera.targetX - camera.x) * ease;
    camera.y += (camera.targetY - camera.y) * ease;
}

function screenToWorld(sx, sy) {
    return {
        x: (sx - W / 2) / camera.zoom - camera.x,
        y: (sy - H / 2) / camera.zoom - camera.y,
    };
}

function worldToScreen(wx, wy) {
    return {
        x: (wx + camera.x) * camera.zoom + W / 2,
        y: (wy + camera.y) * camera.zoom + H / 2,
    };
}

function drawEdges() {
    edgeData.forEach((e, idx) => {
        const a = nodes[e.from], b = nodes[e.to];
        const sa = worldToScreen(a.x, a.y);
        const sb = worldToScreen(b.x, b.y);

        // Skip if both off screen
        if (sa.x < -100 && sb.x < -100) return;
        if (sa.x > W + 100 && sb.x > W + 100) return;
        if (sa.y < -100 && sb.y < -100) return;
        if (sa.y > H + 100 && sb.y > H + 100) return;

        const et = EDGE_TYPES[e.type] || EDGE_TYPES.OWNS;
        const highlight = hoveredNode !== null && (e.from === hoveredNode || e.to === hoveredNode);

        ctx.beginPath();
        if (et.dash) ctx.setLineDash(et.dash);
        else ctx.setLineDash([]);

        ctx.strokeStyle = highlight ? et.color.replace(/[\d.]+\)$/, '0.5)') : et.color;
        ctx.lineWidth = highlight ? 2 : 0.8;
        ctx.moveTo(sa.x, sa.y);
        ctx.lineTo(sb.x, sb.y);
        ctx.stroke();

        // Flow particle
        const flowPos = (time * 0.15 + idx * 0.2) % 1;
        const fx = sa.x + (sb.x - sa.x) * flowPos;
        const fy = sa.y + (sb.y - sa.y) * flowPos;
        ctx.beginPath();
        ctx.arc(fx, fy, highlight ? 2.5 : 1.2, 0, Math.PI * 2);
        ctx.fillStyle = highlight ? et.color.replace(/[\d.]+\)$/, '0.7)') : et.color.replace(/[\d.]+\)$/, '0.3)');
        ctx.fill();
    });
    ctx.setLineDash([]);
}

function drawNodes() {
    nodes.forEach((n, i) => {
        // Gentle floating
        const floatX = Math.sin(time * 0.3 + n.pulsePhase) * 2;
        const floatY = Math.cos(time * 0.25 + n.pulsePhase * 1.3) * 2;
        n.x = n.baseX + floatX;
        n.y = n.baseY + floatY;

        const s = worldToScreen(n.x, n.y);
        if (s.x < -50 || s.x > W + 50 || s.y < -50 || s.y > H + 50) return;

        const col = COLORS[n.type];
        const scaledSize = n.size * camera.zoom;
        const pulse = 1 + Math.sin(time * 2 + n.pulsePhase) * 0.08;
        const r = scaledSize * pulse;
        const isHovered = hoveredNode === i;
        const isConnected = hoveredNode !== null && edgeData.some(
            e => (e.from === hoveredNode && e.to === i) || (e.to === hoveredNode && e.from === i)
        );
        const dimmed = hoveredNode !== null && !isHovered && !isConnected && hoveredNode !== i;

        // Outer glow
        const glowR = r * (isHovered ? 4 : 2.5);
        const grad = ctx.createRadialGradient(s.x, s.y, r * 0.5, s.x, s.y, glowR);
        grad.addColorStop(0, col.glow + (dimmed ? '0.03)' : isHovered ? '0.2)' : '0.06)'));
        grad.addColorStop(1, col.glow + '0)');
        ctx.beginPath();
        ctx.arc(s.x, s.y, glowR, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Node circle
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fillStyle = col.glow + (dimmed ? '0.15)' : isHovered ? '0.95)' : '0.6)');
        ctx.fill();

        // Inner bright dot
        if (!dimmed) {
            ctx.beginPath();
            ctx.arc(s.x, s.y, r * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = col.glow + (isHovered ? '1)' : '0.9)');
            ctx.fill();
        }

        // Label — show when zoomed in enough or when hovered
        const showLabel = camera.zoom > 1.2 || isHovered || isConnected || n.size >= 10;
        if (showLabel && !dimmed) {
            const fontSize = Math.max(9, Math.min(12, 10 * camera.zoom));
            ctx.font = `${isHovered ? '600' : '400'} ${fontSize}px Inter, sans-serif`;
            ctx.fillStyle = col.glow + (dimmed ? '0.2)' : isHovered ? '1)' : '0.55)');
            ctx.textAlign = 'center';
            ctx.fillText(n.label, s.x, s.y + r + fontSize + 4);
        }

        // Type badge when hovered
        if (isHovered) {
            const badgeFontSize = 8;
            ctx.font = `600 ${badgeFontSize}px Inter, sans-serif`;
            ctx.fillStyle = col.glow + '0.4)';
            ctx.textAlign = 'center';
            ctx.fillText(n.type.toUpperCase(), s.x, s.y - r - 8);
        }
    });
}

function checkHover() {
    const worldMouse = screenToWorld(mouse.x, mouse.y);
    let closest = null;
    let closestDist = Infinity;

    nodes.forEach((n, i) => {
        const dx = worldMouse.x - n.x;
        const dy = worldMouse.y - n.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const hitRadius = n.size * 2;
        if (dist < hitRadius && dist < closestDist) {
            closest = i;
            closestDist = dist;
        }
    });

    if (closest !== hoveredNode) {
        hoveredNode = closest;
        updateInfoPanel();
    }
}

function updateInfoPanel() {
    const panel = document.getElementById('infoPanel');
    if (hoveredNode === null) {
        panel.classList.remove('visible');
        return;
    }
    const n = nodes[hoveredNode];
    const col = COLORS[n.type];
    document.getElementById('infoType').textContent = n.type;
    document.getElementById('infoType').style.color = col.fill;
    document.getElementById('infoType').style.border = `1px solid ${col.glow}0.3)`;
    document.getElementById('infoName').textContent = n.label;
    document.getElementById('infoDesc').textContent = n.desc;

    // Count connections
    const conns = edgeData.filter(e => e.from === hoveredNode || e.to === hoveredNode);
    const connTypes = {};
    conns.forEach(c => { connTypes[c.type] = (connTypes[c.type] || 0) + 1; });
    const connStr = Object.entries(connTypes).map(([t, c]) => `${c} ${t}`).join(' · ');
    document.getElementById('infoConns').textContent = `${conns.length} connections: ${connStr}`;
    panel.classList.add('visible');
}

// Background subtle grid
function drawGrid() {
    const gridSize = 60 * camera.zoom;
    const offsetX = (camera.x * camera.zoom + W / 2) % gridSize;
    const offsetY = (camera.y * camera.zoom + H / 2) % gridSize;

    ctx.strokeStyle = 'rgba(200,169,110,0.02)';
    ctx.lineWidth = 0.5;

    for (let x = offsetX; x < W; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    for (let y = offsetY; y < H; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
    }
}

let lastTime = performance.now();
function animate(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    time += dt;

    ctx.fillStyle = '#0B0F14';
    ctx.fillRect(0, 0, W, H);

    applyForces();
    updateCamera(dt);
    checkHover();

    drawGrid();
    drawEdges();
    drawNodes();

    requestAnimationFrame(animate);
}

// Events
canvas.addEventListener('mousemove', e => {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
});

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
    camera.targetZoom = Math.max(0.4, Math.min(4, camera.targetZoom * zoomDelta));
    // Reset auto-zoom timer
    zoomTimer = 0;
}, { passive: false });

canvas.addEventListener('mousedown', e => {
    if (hoveredNode !== null) {
        // Click to focus
        const n = nodes[hoveredNode];
        camera.targetX = -n.x;
        camera.targetY = -n.y;
        camera.targetZoom = 2.5;
        zoomTimer = 0;
    }
});

window.addEventListener('resize', resize);

// Init
resize();
initNodes();
requestAnimationFrame(animate);
</script>
</body>
</html>
