<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Paradox of Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0B0F14;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #E0E0E0;
        }

        .container {
            padding: 40px;
            max-width: 1200px;
        }

        .header {
            margin-bottom: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            color: #C8A96E;
            letter-spacing: 1px;
        }

        .header p {
            font-size: 14px;
            color: #A0A0A0;
            font-weight: 300;
        }

        .canvas-wrapper {
            position: relative;
            background: rgba(11, 15, 20, 0.8);
            border: 1px solid rgba(200, 169, 110, 0.2);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5),
                        inset 0 1px 0 rgba(200, 169, 110, 0.1);
        }

        canvas {
            display: block;
            background: linear-gradient(135deg, rgba(11, 15, 20, 0.9) 0%, rgba(15, 25, 40, 0.9) 100%);
        }

        .description {
            margin-top: 20px;
            font-size: 13px;
            color: #808080;
            text-align: center;
            line-height: 1.6;
        }

        .labels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-top: 20px;
            text-align: center;
        }

        .label {
            font-size: 12px;
            color: #A0A0A0;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .label-left {
            color: rgba(200, 169, 110, 0.7);
        }

        .label-right {
            color: rgba(91, 200, 180, 0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>The Paradox of Control</h1>
            <p>More data, less understanding. More tools, less visibility.</p>
        </div>

        <div class="canvas-wrapper">
            <canvas id="paradoxCanvas" width="600" height="200"></canvas>
        </div>

        <div class="labels">
            <div class="label label-left">Linear Illusion</div>
            <div class="label label-right">Complex Reality</div>
        </div>

        <div class="description">
            The left side shows the comforting appearance of controlâ€”linear metrics, orderly progression, predictable patterns. The right side reveals the actual system: interconnected feedback loops, emergent behaviors, and non-linear dynamics that resist traditional management.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('paradoxCanvas');
        const ctx = canvas.getContext('2d');

        // Color palette
        const colors = {
            gold: 'rgb(200,169,110)',
            rose: 'rgb(200,110,139)',
            teal: 'rgb(91,200,180)',
            blue: 'rgb(110,170,200)',
            background: '#0B0F14'
        };

        // Animation state
        let time = 0;
        const cycleLength = 8000; // 8 seconds per cycle

        // Particle system for the left (linear) side
        class LinearArrow {
            constructor(index, total) {
                this.index = index;
                this.total = total;
                this.x = 50 + (index / (total - 1)) * 100;
                this.y = 100;
                this.baseHeight = 30 + Math.random() * 10;
                this.height = this.baseHeight;
            }

            update(phase) {
                // Gentle oscillation
                this.height = this.baseHeight + Math.sin(phase * 0.5 + this.index) * 5;
            }

            draw(ctx, x, y, width, height) {
                const screenX = x + (this.x / 200) * width;
                const screenY = y + height / 2;

                // Draw arrow shaft
                ctx.strokeStyle = colors.gold;
                ctx.globalAlpha = 0.6;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(screenX, screenY - this.height);
                ctx.stroke();

                // Draw arrow head
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = colors.gold;
                ctx.beginPath();
                ctx.moveTo(screenX - 3, screenY - this.height - 5);
                ctx.lineTo(screenX + 3, screenY - this.height - 5);
                ctx.lineTo(screenX, screenY - this.height);
                ctx.fill();

                ctx.globalAlpha = 1;
            }
        }

        // Nodes and connections for the right (chaotic) side
        class ChaosNode {
            constructor(index, total, phase) {
                const angle = (index / total) * Math.PI * 2;
                this.baseX = Math.cos(angle) * 40;
                this.baseY = Math.sin(angle) * 30;
                this.x = this.baseX;
                this.y = this.baseY;
                this.phase = phase;
                this.wobble = Math.random() * Math.PI * 2;
                this.color = [colors.teal, colors.rose, colors.blue][index % 3];
            }

            update(globalPhase) {
                const wobbleAmount = 15 + Math.sin(globalPhase * 0.3 + this.wobble) * 10;
                const angle = (this.phase / Math.PI / 2) * Math.PI * 2;
                this.x = this.baseX + Math.sin(globalPhase * 0.5 + this.phase) * wobbleAmount;
                this.y = this.baseY + Math.cos(globalPhase * 0.7 + this.phase) * wobbleAmount;
            }

            draw(ctx, x, y, width, height) {
                const screenX = x + width / 2 + this.x;
                const screenY = y + height / 2 + this.y;

                ctx.globalAlpha = 0.7;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
            }
        }

        // Initialize particles
        const linearArrows = [];
        for (let i = 0; i < 6; i++) {
            linearArrows.push(new LinearArrow(i, 6));
        }

        const chaosNodes = [];
        for (let i = 0; i < 8; i++) {
            chaosNodes.push(new ChaosNode(i, 8, i * Math.PI / 4));
        }

        function drawGridLines(ctx, x, y, width, height) {
            ctx.strokeStyle = 'rgba(200,169,110,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const xPos = x + (i / 4) * width;
                ctx.beginPath();
                ctx.moveTo(xPos, y);
                ctx.lineTo(xPos, y + height);
                ctx.stroke();
            }
        }

        function drawDivider(ctx, x, width, height) {
            ctx.strokeStyle = 'rgba(200,169,110,0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(x + width / 2, 0);
            ctx.lineTo(x + width / 2, height);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawConnections(ctx, nodes, x, y, width, height, alpha) {
            ctx.globalAlpha = alpha * 0.3;
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const node1 = nodes[i];
                    const node2 = nodes[j];
                    const screenX1 = x + width / 2 + node1.x;
                    const screenY1 = y + height / 2 + node1.y;
                    const screenX2 = x + width / 2 + node2.x;
                    const screenY2 = y + height / 2 + node2.y;

                    // Probabilistic connections based on distance
                    const dist = Math.hypot(node1.x - node2.x, node1.y - node2.y);
                    if (dist < 60) {
                        ctx.strokeStyle = 'rgba(91,200,180,0.4)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(screenX1, screenY1);
                        ctx.lineTo(screenX2, screenY2);
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1;
        }

        function animate() {
            time = (time + 16) % cycleLength;
            const phase = time / cycleLength;

            // Clear canvas
            ctx.fillStyle = 'rgba(11,15,20,0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const leftX = 0;
            const rightX = canvas.width / 2;
            const sectionWidth = canvas.width / 2;
            const sectionHeight = canvas.height;

            // Draw grid lines on left side
            drawGridLines(ctx, leftX, 0, sectionWidth, sectionHeight);

            // Draw center divider
            drawDivider(ctx, leftX, canvas.width, sectionHeight);

            // ===== LEFT SIDE: LINEAR ILLUSION =====
            // Update and draw linear arrows
            linearArrows.forEach(arrow => {
                arrow.update(phase * Math.PI * 2);
                arrow.draw(ctx, leftX, 0, sectionWidth, sectionHeight);
            });

            // Draw horizontal reference line
            ctx.strokeStyle = 'rgba(200,169,110,0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(leftX, sectionHeight / 2);
            ctx.lineTo(leftX + sectionWidth, sectionHeight / 2);
            ctx.stroke();

            // ===== RIGHT SIDE: COMPLEX REALITY =====
            // Update nodes
            chaosNodes.forEach(node => {
                node.update(phase * Math.PI * 2);
            });

            // Draw connections
            drawConnections(ctx, chaosNodes, rightX, 0, sectionWidth, sectionHeight, 1);

            // Draw nodes
            chaosNodes.forEach(node => {
                node.draw(ctx, rightX, 0, sectionWidth, sectionHeight);
            });

            // Add subtle glow effect
            ctx.shadowColor = 'rgba(91,200,180,0.3)';
            ctx.shadowBlur = 10;
            chaosNodes.forEach(node => {
                const screenX = rightX + sectionWidth / 2 + node.x;
                const screenY = sectionHeight / 2 + node.y;
                ctx.fillStyle = node.color;
                ctx.globalAlpha = 0.2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowColor = 'transparent';
            ctx.globalAlpha = 1;

            // ===== TRANSITION EFFECT =====
            // Create pulsing feedback loops when phase is in certain ranges
            if (phase > 0.3 && phase < 0.7) {
                const pulseStrength = Math.sin((phase - 0.3) / 0.4 * Math.PI);
                ctx.strokeStyle = `rgba(200,110,139,${pulseStrength * 0.3})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(rightX + sectionWidth / 2, sectionHeight / 2, 25 + pulseStrength * 10, 0, Math.PI * 2);
                ctx.stroke();
            }

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();
    </script>
</body>
</html>
